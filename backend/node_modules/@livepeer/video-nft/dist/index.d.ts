/// <reference types="node" />
import { ethers } from 'ethers';

declare type ChainSpec = {
    chainId: `0x${string}`;
    chainName: string;
    rpcUrls: string[];
    nativeCurrency: {
        symbol: string;
        decimals: number;
        [unknown: string]: any;
    };
    blockExplorerUrls: string[];
    iconUrls?: string[];
    [unknown: string]: any;
};
declare type BuiltinChainInfo = {
    spec: ChainSpec;
    defaultContract: `0x${string}`;
    opensea?: {
        baseUrl: string;
        chainName: string;
    };
};
declare function toHexChainId(chainId: string | number | undefined): string;
declare function toNumberChainId(chainId: string | number): number;
declare function isChainBuiltin(chainId: string | number): boolean;
declare function listBuiltinChains(): string[];
declare function getBuiltinChain(chainId: string | number): BuiltinChainInfo | null;
declare function switchChain(ethereum: ethers.providers.ExternalProvider, chainId: string): Promise<any>;
declare function addChain(ethereum: ethers.providers.ExternalProvider, chainSpec: ChainSpec): Promise<any>;
declare function switchOrAddChain(ethereum: ethers.providers.ExternalProvider, chainSpec: ChainSpec): Promise<{
    added: boolean;
}>;

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
/**
 * LMPS ffmpeg profile
 */
interface FfmpegProfile {
    width: number;
    name: string;
    height: number;
    bitrate: number;
    fps: number;
    fpsDen?: number;
    gop?: string;
    profile?: 'H264Baseline' | 'H264Main' | 'H264High' | 'H264ConstrainedHigh';
    encoder?: 'h264' | 'hevc' | 'vp8' | 'vp9';
}
/**
 * LMPS ffmpeg profile
 */
interface FfmpegProfile {
    width: number;
    name: string;
    height: number;
    bitrate: number;
    fps: number;
    fpsDen?: number;
    gop?: string;
    profile?: 'H264Baseline' | 'H264Main' | 'H264High' | 'H264ConstrainedHigh';
    encoder?: 'h264' | 'hevc' | 'vp8' | 'vp9';
}
/**
 * LMPS ffmpeg profile
 */
interface FfmpegProfile {
    width: number;
    name: string;
    height: number;
    bitrate: number;
    fps: number;
    fpsDen?: number;
    gop?: string;
    profile?: 'H264Baseline' | 'H264Main' | 'H264High' | 'H264ConstrainedHigh';
    encoder?: 'h264' | 'hevc' | 'vp8' | 'vp9';
}
/**
 * LMPS ffmpeg profile
 */
interface FfmpegProfile {
    width: number;
    name: string;
    height: number;
    bitrate: number;
    fps: number;
    fpsDen?: number;
    gop?: string;
    profile?: 'H264Baseline' | 'H264Main' | 'H264High' | 'H264ConstrainedHigh';
    encoder?: 'h264' | 'hevc' | 'vp8' | 'vp9';
}
/**
 * LMPS ffmpeg profile
 */
interface FfmpegProfile {
    width: number;
    name: string;
    height: number;
    bitrate: number;
    fps: number;
    fpsDen?: number;
    gop?: string;
    profile?: 'H264Baseline' | 'H264Main' | 'H264High' | 'H264ConstrainedHigh';
    encoder?: 'h264' | 'hevc' | 'vp8' | 'vp9';
}
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
interface Asset {
    id: string;
    /**
     * Type of the asset.
     */
    type?: 'video' | 'audio';
    /**
     * Used to form playback URL and storage folder
     */
    playbackId?: string;
    /**
     * URL to manually download the asset if desired
     */
    downloadUrl?: string;
    /**
     * owner of the asset
     */
    userId?: string;
    /**
     * Set to true when the asset is deleted
     */
    deleted?: boolean;
    /**
     * Object store ID where the asset is stored
     */
    objectStoreId?: string;
    /**
     * Name of the asset. This is not necessarily the filename, can be a custom name or title
     */
    name: string;
    /**
     * User input metadata associated with the asset
     */
    meta?: {
        [k: string]: string;
    };
    /**
     * Timestamp (in milliseconds) at which the asset was last updated
     */
    updatedAt?: number;
    /**
     * Timestamp (in milliseconds) at which asset was created
     */
    createdAt?: number;
    /**
     * Size of the asset in bytes
     */
    size?: number;
    /**
     * Hash of the asset
     */
    hash?: {
        /**
         * Hash of the asset
         */
        hash?: string;
        /**
         * Hash algorithm used to compute the hash
         */
        algorithm?: string;
    }[];
    /**
     * Video metadata
     */
    videoSpec?: {
        /**
         * Format of the asset
         */
        format?: string;
        /**
         * Duration of the asset in seconds (float)
         */
        duration?: number;
        /**
         * Bitrate of the video in bits per second
         */
        bitrate?: number;
        /**
         * List of tracks associated with the asset when the format contemplates them (e.g. mp4)
         */
        tracks?: {
            /**
             * type of track
             */
            type: 'video' | 'audio';
            /**
             * Codec of the track
             */
            codec: string;
            /**
             * Start time of the track in seconds
             */
            startTime?: number;
            /**
             * Duration of the track in seconds
             */
            duration?: number;
            /**
             * Bitrate of the track in bits per second
             */
            bitrate?: number;
            /**
             * Width of the track - only for video tracks
             */
            width?: number;
            /**
             * Height of the track - only for video tracks
             */
            height?: number;
            /**
             * Pixel format of the track - only for video tracks
             */
            pixelFormat?: string;
            /**
             * Frame rate of the track - only for video tracks
             */
            fps?: number;
            /**
             * Amount of audio channels in the track
             */
            channels?: number;
            /**
             * Sample rate of the track in samples per second - only for audio tracks
             */
            sampleRate?: number;
            /**
             * Bit depth of the track - only for audio tracks
             */
            bitDepth?: number;
        }[];
    };
    /**
     * Status of the asset
     */
    status?: 'waiting' | 'ready' | 'failed';
    /**
     * ID of the source asset (root) - If missing, this is a root asset
     */
    sourceAssetId?: string;
}
interface Asset {
    id: string;
    /**
     * Type of the asset.
     */
    type?: 'video' | 'audio';
    /**
     * Used to form playback URL and storage folder
     */
    playbackId?: string;
    /**
     * URL to manually download the asset if desired
     */
    downloadUrl?: string;
    /**
     * owner of the asset
     */
    userId?: string;
    /**
     * Set to true when the asset is deleted
     */
    deleted?: boolean;
    /**
     * Object store ID where the asset is stored
     */
    objectStoreId?: string;
    /**
     * Name of the asset. This is not necessarily the filename, can be a custom name or title
     */
    name: string;
    /**
     * User input metadata associated with the asset
     */
    meta?: {
        [k: string]: string;
    };
    /**
     * Timestamp (in milliseconds) at which the asset was last updated
     */
    updatedAt?: number;
    /**
     * Timestamp (in milliseconds) at which asset was created
     */
    createdAt?: number;
    /**
     * Size of the asset in bytes
     */
    size?: number;
    /**
     * Hash of the asset
     */
    hash?: {
        /**
         * Hash of the asset
         */
        hash?: string;
        /**
         * Hash algorithm used to compute the hash
         */
        algorithm?: string;
    }[];
    /**
     * Video metadata
     */
    videoSpec?: {
        /**
         * Format of the asset
         */
        format?: string;
        /**
         * Duration of the asset in seconds (float)
         */
        duration?: number;
        /**
         * Bitrate of the video in bits per second
         */
        bitrate?: number;
        /**
         * List of tracks associated with the asset when the format contemplates them (e.g. mp4)
         */
        tracks?: {
            /**
             * type of track
             */
            type: 'video' | 'audio';
            /**
             * Codec of the track
             */
            codec: string;
            /**
             * Start time of the track in seconds
             */
            startTime?: number;
            /**
             * Duration of the track in seconds
             */
            duration?: number;
            /**
             * Bitrate of the track in bits per second
             */
            bitrate?: number;
            /**
             * Width of the track - only for video tracks
             */
            width?: number;
            /**
             * Height of the track - only for video tracks
             */
            height?: number;
            /**
             * Pixel format of the track - only for video tracks
             */
            pixelFormat?: string;
            /**
             * Frame rate of the track - only for video tracks
             */
            fps?: number;
            /**
             * Amount of audio channels in the track
             */
            channels?: number;
            /**
             * Sample rate of the track in samples per second - only for audio tracks
             */
            sampleRate?: number;
            /**
             * Bit depth of the track - only for audio tracks
             */
            bitDepth?: number;
        }[];
    };
    /**
     * Status of the asset
     */
    status?: 'waiting' | 'ready' | 'failed';
    /**
     * ID of the source asset (root) - If missing, this is a root asset
     */
    sourceAssetId?: string;
}

declare type ApiAuthorization = {
    apiKey: string;
} | {
    jwt: string;
};

declare type EthereumOrProvider = ethers.providers.ExternalProvider | ethers.providers.JsonRpcFetchFunc | ethers.providers.JsonRpcProvider;
declare type MintedNftInfo = {
    tokenId?: number;
    opensea?: {
        tokenUrl?: string;
        contractUrl: string;
    };
};
declare class VideoNFT {
    private ethProvider?;
    private chainId;
    private api;
    constructor(api?: {
        auth?: ApiAuthorization;
        endpoint?: string;
    }, web3?: {
        ethereum: EthereumOrProvider;
        chainId: string | number;
    });
    createNft(args: {
        assetName: string;
        skipNormalize: boolean;
        nftMetadata: string;
        mint: {
            contractAddress?: string;
            to?: string;
        };
    }): Promise<MintedNftInfo | null>;
    pickFile(): Promise<File>;
    createAsset(name: string, content: File | NodeJS.ReadableStream, reportProgress?: (progress: number) => void): Promise<Asset>;
    checkNftNormalize(asset: Asset): {
        possible: boolean;
        desiredProfile: FfmpegProfile | null;
    };
    nftNormalize(asset: Asset, reportProgress?: (progress: number) => void): Promise<Asset>;
    exportToIPFS(assetId: string, nftMetadata?: string | Record<string, any>, reportProgress?: (progress: number) => void): Promise<{
        videoFileCid: string;
        videoFileUrl?: string | undefined;
        videoFileGatewayUrl?: string | undefined;
        nftMetadataCid?: string | undefined;
        nftMetadataUrl?: string | undefined;
        nftMetadataGatewayUrl?: string | undefined;
    } | undefined>;
    mintNft(tokenUri: string, contractAddress?: string, to?: string): Promise<ethers.ContractTransaction>;
    getMintedNftInfo(tx: ethers.ContractTransaction): Promise<MintedNftInfo>;
}

export { BuiltinChainInfo, ChainSpec, VideoNFT, addChain, getBuiltinChain, isChainBuiltin, listBuiltinChains, switchChain, switchOrAddChain, toHexChainId, toNumberChainId };

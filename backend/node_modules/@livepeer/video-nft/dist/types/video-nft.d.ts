/// <reference types="node" />
import { ethers } from 'ethers';
import { ApiAuthorization } from './api';
import { Asset, FfmpegProfile } from './types/schema';
declare type EthereumOrProvider = ethers.providers.ExternalProvider | ethers.providers.JsonRpcFetchFunc | ethers.providers.JsonRpcProvider;
declare type MintedNftInfo = {
    tokenId?: number;
    opensea?: {
        tokenUrl?: string;
        contractUrl: string;
    };
};
export declare class VideoNFT {
    private ethProvider?;
    private chainId;
    private api;
    constructor(api?: {
        auth?: ApiAuthorization;
        endpoint?: string;
    }, web3?: {
        ethereum: EthereumOrProvider;
        chainId: string | number;
    });
    createNft(args: {
        assetName: string;
        skipNormalize: boolean;
        nftMetadata: string;
        mint: {
            contractAddress?: string;
            to?: string;
        };
    }): Promise<MintedNftInfo | null>;
    pickFile(): Promise<File>;
    createAsset(name: string, content: File | NodeJS.ReadableStream, reportProgress?: (progress: number) => void): Promise<Asset>;
    checkNftNormalize(asset: Asset): {
        possible: boolean;
        desiredProfile: FfmpegProfile | null;
    };
    nftNormalize(asset: Asset, reportProgress?: (progress: number) => void): Promise<Asset>;
    exportToIPFS(assetId: string, nftMetadata?: string | Record<string, any>, reportProgress?: (progress: number) => void): Promise<{
        videoFileCid: string;
        videoFileUrl?: string | undefined;
        videoFileGatewayUrl?: string | undefined;
        nftMetadataCid?: string | undefined;
        nftMetadataUrl?: string | undefined;
        nftMetadataGatewayUrl?: string | undefined;
    } | undefined>;
    mintNft(tokenUri: string, contractAddress?: string, to?: string): Promise<ethers.ContractTransaction>;
    getMintedNftInfo(tx: ethers.ContractTransaction): Promise<MintedNftInfo>;
}
export {};

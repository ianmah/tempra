declare type Camel<T extends string> = T extends `${infer Left}-${infer Right}` ? Camel<`${Left}${Capitalize<Right>}`> : T;
declare type CamelKeys<T> = {
    [K in keyof T as K extends string ? Camel<K> : K]: T[K];
};
declare type UnboxPromise<T> = T extends Promise<infer U> ? U : never;
declare type RawArgs = UnboxPromise<ReturnType<typeof parseRawArgs>>;
export declare type CliArgs = CamelKeys<{
    [K in keyof RawArgs]: Exclude<RawArgs[K], undefined>;
}>;
declare function parseRawArgs(argv?: string | readonly string[]): {
    [x: string]: unknown;
    filename: string | undefined;
    "api-key": string | undefined;
    apiKey: string | undefined;
    "asset-name": string | undefined;
    assetName: string | undefined;
    "nft-metadata": string;
    nftMetadata: string;
    "api-endpoint": string;
    apiEndpoint: string;
    _: (string | number)[];
    $0: string;
} | Promise<{
    [x: string]: unknown;
    filename: string | undefined;
    "api-key": string | undefined;
    apiKey: string | undefined;
    "asset-name": string | undefined;
    assetName: string | undefined;
    "nft-metadata": string;
    nftMetadata: string;
    "api-endpoint": string;
    apiEndpoint: string;
    _: (string | number)[];
    $0: string;
}>;
export default function parseCli(argv?: string | readonly string[]): Promise<CliArgs>;
export {};

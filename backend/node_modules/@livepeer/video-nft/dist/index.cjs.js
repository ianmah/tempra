'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var ethers = require('ethers');
var axios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

const builtinChains = {
    '0x89': {
        spec: {
            chainId: '0x89',
            chainName: 'Polygon Mainnet',
            rpcUrls: ['https://polygon-rpc.com/'],
            nativeCurrency: { symbol: 'MATIC', decimals: 18 },
            blockExplorerUrls: ['https://polygonscan.com'],
            iconUrls: [
                'https://cloudflare-ipfs.com/ipfs/bafkreiduv5pzw233clfjuahv5lkq2xvjomapou7yarik2lynu3bjm2xki4'
            ]
        },
        defaultContract: '0x69C53E7b8c41bF436EF5a2D81DB759Dc8bD83b5F',
        opensea: {
            baseUrl: 'https://opensea.io',
            chainName: 'matic'
        }
    },
    '0x13881': {
        spec: {
            chainId: '0x13881',
            chainName: 'Polygon Testnet',
            rpcUrls: ['https://matic-mumbai.chainstacklabs.com'],
            nativeCurrency: { symbol: 'MATIC', decimals: 18 },
            blockExplorerUrls: ['https://mumbai.polygonscan.com']
        },
        defaultContract: '0xA4E1d8FE768d471B048F9d73ff90ED8fcCC03643',
        opensea: {
            baseUrl: 'https://testnets.opensea.io',
            chainName: 'mumbai'
        }
    }
};
function toHexChainId(chainId) {
    return chainId == null ? '' : ethers.utils.hexValue(chainId);
}
function toNumberChainId(chainId) {
    return parseInt(toHexChainId(chainId), 16);
}
function isChainBuiltin(chainId) {
    return !!builtinChains[toHexChainId(chainId)];
}
function listBuiltinChains() {
    return Object.keys(builtinChains);
}
function getBuiltinChain(chainId) {
    return builtinChains[toHexChainId(chainId)] || null;
}
function switchChain(ethereum, chainId) {
    if (!ethereum.request) {
        throw new Error('ethereum provider does not support request');
    }
    return ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId }]
    });
}
function addChain(ethereum, chainSpec) {
    if (!ethereum.request) {
        throw new Error('ethereum provider does not support request');
    }
    return ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [chainSpec]
    });
}
function switchOrAddChain(ethereum, chainSpec) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        try {
            yield switchChain(ethereum, chainSpec.chainId);
            return { added: false };
        }
        catch (err) {
            // 4902 is the not found error code
            if (err.code !== 4902) {
                throw err;
            }
        }
        yield addChain(ethereum, chainSpec);
        return { added: true };
    });
}

class VodApi {
    constructor(auth, apiEndpoint = '') {
        this.client = axios__default["default"].create({
            baseURL: apiEndpoint,
            headers: {
                Authorization: !auth
                    ? ''
                    : 'apiKey' in auth
                        ? `Bearer ${auth.apiKey}`
                        : 'jwt' in auth
                            ? `JWT ${auth.jwt}`
                            : ''
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            maxRedirects: 0
        });
        this.client.interceptors.response.use(res => {
            if (res.status >= 300) {
                throw new Error(`Error on ${res.config.method} ${res.config.url} (${res.status} ${res.statusText}): ${JSON.stringify(res.data)}`);
            }
            return res;
        });
    }
    getAsset(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('get', `/api/asset/${id}`);
        });
    }
    getTask(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('get', `/api/task/${id}`);
        });
    }
    requestUploadUrl(assetName) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('post', `/api/asset/request-upload`, {
                name: assetName
            });
        });
    }
    uploadFile(url, content, mimeType, reportProgress) {
        const defaultMimeType = typeof File !== 'undefined' && content instanceof File
            ? content.type
            : 'application/octet-stream';
        return this.makeRequest('put', url, content, {
            headers: {
                contentType: mimeType || defaultMimeType
            },
            onUploadProgress: reportProgress && (p => reportProgress(p.loaded / p.total))
        });
    }
    transcodeAsset(src, profile, name) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('post', `/api/asset/transcode`, {
                assetId: src.id,
                name: name !== null && name !== void 0 ? name : `${src.name} (${profile.name})`,
                profile
            });
        });
    }
    exportAsset(id, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('post', `/api/asset/${id}/export`, params);
        });
    }
    // next level utilities
    waitTask(task, reportProgress) {
        var _a, _b, _c, _d;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let lastProgress = 0;
            while (((_a = task.status) === null || _a === void 0 ? void 0 : _a.phase) !== 'completed' &&
                ((_b = task.status) === null || _b === void 0 ? void 0 : _b.phase) !== 'failed') {
                const progress = (_c = task.status) === null || _c === void 0 ? void 0 : _c.progress;
                if (progress && progress !== lastProgress) {
                    if (reportProgress)
                        reportProgress(progress);
                    lastProgress = progress;
                }
                new Promise(resolve => setTimeout(resolve, 1000));
                task = yield this.getTask((_d = task.id) !== null && _d !== void 0 ? _d : '');
            }
            if (task.status.phase === 'failed') {
                throw new Error(`${task.type} task failed. error: ${task.status.errorMessage}`);
            }
            return task;
        });
    }
    makeRequest(method, url, data, additionalConfig) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.client.request(Object.assign(Object.assign({}, additionalConfig), { method,
                    url,
                    data }));
                return res.data;
            }
            catch (err) {
                if (!axios__default["default"].isAxiosError(err) || !err.response) {
                    throw err;
                }
                const { status, statusText, data } = err.response;
                let msg = JSON.stringify(data);
                if (Array.isArray(data.errors) && data.errors.length > 0) {
                    msg = data.errors[0];
                }
                throw new Error(`Request to ${url} failed (${status} ${statusText}): ${msg}`);
            }
        });
    }
}

var T=Object.defineProperty;var f=(e,t)=>()=>(e&&(t=e(e=0)),t);var d=(e,t)=>{for(var i in t)T(e,i,{get:t[i],enumerable:!0});};var y={};d(y,{default:()=>E});var E,p=f(()=>{E=async(e=[{}])=>(Array.isArray(e)||(e=[e]),new Promise((t,i)=>{let r=document.createElement("input");r.type="file";let l=[...e.map(s=>s.mimeTypes||[]),...e.map(s=>s.extensions||[])].join();r.multiple=e[0].multiple||!1,r.accept=l||"";let n=()=>c(i),a=s=>{typeof c=="function"&&c(),t(s);},c=e[0].legacySetup&&e[0].legacySetup(a,n,r);r.addEventListener("change",()=>{a(r.multiple?Array.from(r.files):r.files[0]);}),r.click();}));});var w={};d(w,{default:()=>I});var N,I,h=f(()=>{N=async e=>{let t=await e.getFile();return t.handle=e,t},I=async(e=[{}])=>{Array.isArray(e)||(e=[e]);let t=[];e.forEach((l,n)=>{t[n]={description:l.description||"",accept:{}},l.mimeTypes?l.mimeTypes.map(a=>{t[n].accept[a]=l.extensions||[];}):t[n].accept["*/*"]=l.extensions||[];});let i=await window.showOpenFilePicker({id:e[0].id,startIn:e[0].startIn,types:t,multiple:e[0].multiple||!1,excludeAcceptAllOption:e[0].excludeAcceptAllOption||!1}),r=await Promise.all(i.map(N));return e[0].multiple?r:r[0]};});var o={};d(o,{default:()=>M});var M,A=f(()=>{M=async(e=[{}])=>(Array.isArray(e)||(e=[e]),e[0].recursive=e[0].recursive||!1,new Promise((t,i)=>{let r=document.createElement("input");r.type="file",r.webkitdirectory=!0;let l=()=>a(i),n=c=>{typeof a=="function"&&a(),t(c);},a=e[0].legacySetup&&e[0].legacySetup(n,l,r);r.addEventListener("change",()=>{let c=Array.from(r.files);e[0].recursive?e[0].recursive&&e[0].skipDirectory&&(c=c.filter(s=>s.webkitRelativePath.split("/").every(S=>!e[0].skipDirectory({name:S,kind:"directory"})))):c=c.filter(s=>s.webkitRelativePath.split("/").length===2),n(c);}),r.click();}));});var x={};d(x,{default:()=>B});var v,B,g=f(()=>{v=async(e,t,i=e.name,r)=>{let l=[],n=[];for await(let a of e.values()){let c=`${i}/${a.name}`;a.kind==="file"?n.push(a.getFile().then(s=>(s.directoryHandle=e,s.handle=a,Object.defineProperty(s,"webkitRelativePath",{configurable:!0,enumerable:!0,get:()=>c})))):a.kind==="directory"&&t&&(!r||!r(a))&&l.push(v(a,t,c,r));}return [...(await Promise.all(l)).flat(),...await Promise.all(n)]},B=async(e={})=>{e.recursive=e.recursive||!1;let t=await window.showDirectoryPicker({id:e.id,startIn:e.startIn});return v(t,e.recursive,void 0,e.skipDirectory)};});var k={};d(k,{default:()=>W});async function $(e,t){let i=e.getReader(),r=new ReadableStream({start(n){return a();async function a(){return i.read().then(({done:c,value:s})=>{if(c){n.close();return}return n.enqueue(s),a()})}}}),l=new Response(r);return i.releaseLock(),new Blob([await l.blob()],{type:t})}var W,P=f(()=>{W=async(e,t={})=>{Array.isArray(t)&&(t=t[0]);let i=document.createElement("a"),r=e;"body"in e&&(r=await $(e.body,e.headers.get("content-type"))),i.download=t.fileName||"Untitled",i.href=URL.createObjectURL(r);let l=()=>a(reject),n=()=>{typeof a=="function"&&a();},a=t.legacySetup&&t.legacySetup(n,l,i);return i.addEventListener("click",()=>{setTimeout(()=>URL.revokeObjectURL(i.href),30*1e3),n();}),i.click(),null};});var j={};d(j,{default:()=>q});var q,L=f(()=>{q=async(e,t=[{}],i=null,r=!1)=>{Array.isArray(t)||(t=[t]),t[0].fileName=t[0].fileName||"Untitled";let l=[];if(t.forEach((c,s)=>{l[s]={description:c.description||"",accept:{}},c.mimeTypes?(s===0&&(e.type?c.mimeTypes.push(e.type):e.headers&&e.headers.get("content-type")&&c.mimeTypes.push(e.headers.get("content-type"))),c.mimeTypes.map(m=>{l[s].accept[m]=c.extensions||[];})):e.type&&(l[s].accept[e.type]=c.extensions||[]);}),i)try{await i.getFile();}catch(c){if(i=null,r)throw c}let n=i||await window.showSaveFilePicker({suggestedName:t[0].fileName,id:t[0].id,startIn:t[0].startIn,types:l,excludeAcceptAllOption:t[0].excludeAcceptAllOption||!1}),a=await n.createWritable();return "stream"in e?(await e.stream().pipeTo(a),n):"body"in e?(await e.body.pipeTo(a),n):(await a.write(blob),await a.close(),n)};});var F=(()=>{if(typeof self>"u")return !1;if("top"in self&&self!==top)try{top.location+"";}catch{return !1}else if("showOpenFilePicker"in self)return "showOpenFilePicker";return !1})(),u=F;var U=u?Promise.resolve().then(()=>(h(),w)):Promise.resolve().then(()=>(p(),y));async function _(...e){return (await U).default(...e)}u?Promise.resolve().then(()=>(g(),x)):Promise.resolve().then(()=>(A(),o));u?Promise.resolve().then(()=>(L(),j)):Promise.resolve().then(()=>(P(),k));// @license Â© 2020 Google LLC. Licensed under the Apache License, Version 2.0.

const openSeaNftSizeLimit = 100000000; // 100 MB
const min720pBitrate = 500000; // 0.5 Mbps
const minBitrate = 100000; // 0.1 Mbps
function getDesiredBitrate(asset, sizeLimit = openSeaNftSizeLimit) {
    var _a, _b, _c, _d, _e, _f;
    const size = (_a = asset.size) !== null && _a !== void 0 ? _a : 0;
    const bitrate = (_c = (_b = getVideoTrack(asset)) === null || _b === void 0 ? void 0 : _b.bitrate) !== null && _c !== void 0 ? _c : 0;
    if (size <= sizeLimit || !bitrate) {
        return null;
    }
    const audioTrack = (_e = (_d = asset.videoSpec) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e === void 0 ? void 0 : _e.find(t => t.type === 'audio');
    const audioBitrate = (_f = audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.bitrate) !== null && _f !== void 0 ? _f : 0;
    const desiredBitrate = Math.floor((bitrate + audioBitrate) * (sizeLimit / size) - audioBitrate);
    if (desiredBitrate < minBitrate) {
        throw new Error('Asset is too large to be downscaled to desired size');
    }
    return desiredBitrate;
}
function makeProfile(asset, desiredBitrate) {
    var _a;
    const { bitrate = 1, width = 0, height = 0 } = (_a = getVideoTrack(asset)) !== null && _a !== void 0 ? _a : {};
    // We only change the resolution if the bitrate changes too much. We don't go
    // below 720p though since the bitrate is the thing that really matters. We
    // don't need to handle aspect ratio since go-livepeer will do it for us.
    const referenceHeight = height * Math.sqrt(desiredBitrate / bitrate);
    const resolution = height < 480 || referenceHeight > 720
        ? { name: 'low-bitrate', width, height }
        : desiredBitrate < min720pBitrate
            ? { name: '480p', width: 854, height: 480 }
            : { name: '720p', width: 1280, height: 720 };
    return Object.assign(Object.assign({}, resolution), { bitrate: desiredBitrate, fps: 0 });
}
function getVideoTrack(asset) {
    var _a, _b;
    return (_b = (_a = asset.videoSpec) === null || _a === void 0 ? void 0 : _a.tracks) === null || _b === void 0 ? void 0 : _b.find(t => t.type === 'video');
}

const asJsonRpcProvider = (ethOrPrv) => !ethOrPrv
    ? undefined
    : ethOrPrv instanceof ethers.ethers.providers.JsonRpcProvider
        ? ethOrPrv
        : new ethers.ethers.providers.Web3Provider(ethOrPrv);
const videoNftAbi = [
    'event Mint(address indexed sender, address indexed owner, string tokenURI, uint256 tokenId)',
    'function mint(address owner, string tokenURI) returns (uint256)'
];
class VideoNFT {
    constructor(api, web3) {
        this.api = new VodApi(api === null || api === void 0 ? void 0 : api.auth, api === null || api === void 0 ? void 0 : api.endpoint);
        this.ethProvider = asJsonRpcProvider(web3 === null || web3 === void 0 ? void 0 : web3.ethereum);
        // The chainId would not be really necessary since we can get it from the
        // provider. But the provider explodes if the chain changes, so we force
        // users to send the chainId here so it's clear they need to recreate
        // the SDK instance if the chain changes.
        this.chainId = toHexChainId(web3 === null || web3 === void 0 ? void 0 : web3.chainId);
    }
    createNft(args) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const file = yield this.pickFile();
            let asset = yield this.createAsset(args.assetName, file);
            if (!args.skipNormalize) {
                asset = yield this.nftNormalize(asset);
            }
            const ipfsInfo = yield this.exportToIPFS(asset.id, args.nftMetadata);
            if (!args.mint || !this.ethProvider) {
                return null;
            }
            const { mint: { contractAddress, to } } = args;
            const tx = yield this.mintNft((_a = ipfsInfo === null || ipfsInfo === void 0 ? void 0 : ipfsInfo.nftMetadataUrl) !== null && _a !== void 0 ? _a : '', contractAddress, to);
            return this.getMintedNftInfo(tx);
        });
    }
    pickFile() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof window === 'undefined') {
                throw new Error('pickFile is only supported in the browser');
            }
            const { handle } = yield _({
                description: 'MP4 Video files',
                mimeTypes: ['video/mp4'],
                extensions: ['.mp4', '.mov', '.m4v']
            });
            const file = yield (handle === null || handle === void 0 ? void 0 : handle.getFile());
            if (!file) {
                throw new Error('Failed to open file');
            }
            return file;
        });
    }
    createAsset(name, content, reportProgress = () => { }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { url: uploadUrl, asset: { id: assetId }, task } = yield this.api.requestUploadUrl(name);
            yield this.api.uploadFile(uploadUrl, content, undefined, p => reportProgress(p / 2));
            yield this.api.waitTask(task, p => reportProgress(0.5 + p / 2));
            return yield this.api.getAsset(assetId);
        });
    }
    checkNftNormalize(asset) {
        let desiredProfile = null;
        try {
            const desiredBitrate = getDesiredBitrate(asset);
            if (desiredBitrate) {
                desiredProfile = makeProfile(asset, desiredBitrate);
            }
            return {
                possible: true,
                desiredProfile
            };
        }
        catch (e) {
            return { possible: false, desiredProfile };
        }
    }
    nftNormalize(asset, reportProgress) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { possible, desiredProfile } = this.checkNftNormalize(asset);
            if (!possible || !desiredProfile) {
                return asset;
            }
            const transcode = yield this.api.transcodeAsset(asset, desiredProfile);
            yield this.api.waitTask(transcode.task, reportProgress);
            return yield this.api.getAsset(transcode.asset.id);
        });
    }
    exportToIPFS(assetId, nftMetadata, reportProgress) {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof nftMetadata === 'string') {
                nftMetadata = JSON.parse(nftMetadata);
            }
            let { task } = yield this.api.exportAsset(assetId, {
                ipfs: { nftMetadata }
            });
            task = yield this.api.waitTask(task, reportProgress);
            return (_b = (_a = task.output) === null || _a === void 0 ? void 0 : _a.export) === null || _b === void 0 ? void 0 : _b.ipfs;
        });
    }
    mintNft(tokenUri, contractAddress, to) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            contractAddress || (contractAddress = (_a = getBuiltinChain(this.chainId)) === null || _a === void 0 ? void 0 : _a.defaultContract);
            if (!contractAddress) {
                throw new Error('No contract address provided nor builtin chain');
            }
            if (!this.ethProvider) {
                throw new Error('No Ethereum provider configured');
            }
            const net = yield this.ethProvider.getNetwork();
            const currChainId = toHexChainId(net.chainId);
            if (currChainId !== this.chainId) {
                throw new Error(`Inconsistent chain ID: created for ${this.chainId} but found ${currChainId}`);
            }
            const signer = this.ethProvider.getSigner();
            const videoNft = new ethers.ethers.Contract(contractAddress, videoNftAbi, signer);
            const owner = to !== null && to !== void 0 ? to : (yield signer.getAddress());
            return yield videoNft.mint(owner, tokenUri);
        });
    }
    getMintedNftInfo(tx) {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const receipt = yield tx.wait();
            const mintEv = (_b = (_a = receipt.events) === null || _a === void 0 ? void 0 : _a.find(ev => (ev === null || ev === void 0 ? void 0 : ev.event) === 'Mint')) === null || _b === void 0 ? void 0 : _b.args;
            const tokenId = mintEv && mintEv.length > 3
                ? mintEv[3].toNumber()
                : undefined;
            let info = { tokenId };
            const chainInfo = getBuiltinChain(this.chainId);
            if (chainInfo === null || chainInfo === void 0 ? void 0 : chainInfo.opensea) {
                const { opensea: { baseUrl, chainName } } = chainInfo;
                const { to: contractAddr } = receipt;
                info = Object.assign(Object.assign({}, info), { opensea: {
                        contractUrl: `${baseUrl}/assets?search%5Bquery%5D=${contractAddr}`,
                        tokenUrl: !tokenId
                            ? undefined
                            : `${baseUrl}/assets/${chainName}/${contractAddr}/${tokenId}`
                    } });
            }
            return info;
        });
    }
}

exports.VideoNFT = VideoNFT;
exports.addChain = addChain;
exports.getBuiltinChain = getBuiltinChain;
exports.isChainBuiltin = isChainBuiltin;
exports.listBuiltinChains = listBuiltinChains;
exports.switchChain = switchChain;
exports.switchOrAddChain = switchOrAddChain;
exports.toHexChainId = toHexChainId;
exports.toNumberChainId = toNumberChainId;
//# sourceMappingURL=index.cjs.js.map

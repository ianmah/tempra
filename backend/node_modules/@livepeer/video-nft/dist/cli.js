'use strict';

var tslib = require('tslib');
var fs = require('fs');
var inquirer = require('inquirer');
var path = require('path');
var yargs = require('yargs');
var helpers = require('yargs/helpers');
var axios = require('axios');
var ethers = require('ethers');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var inquirer__default = /*#__PURE__*/_interopDefaultLegacy(inquirer);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var yargs__default = /*#__PURE__*/_interopDefaultLegacy(yargs);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

const prodApiEndpoint = 'https://livepeer.com';
class VodApi {
    constructor(auth, apiEndpoint = '') {
        this.client = axios__default["default"].create({
            baseURL: apiEndpoint,
            headers: {
                Authorization: !auth
                    ? ''
                    : 'apiKey' in auth
                        ? `Bearer ${auth.apiKey}`
                        : 'jwt' in auth
                            ? `JWT ${auth.jwt}`
                            : ''
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            maxRedirects: 0
        });
        this.client.interceptors.response.use(res => {
            if (res.status >= 300) {
                throw new Error(`Error on ${res.config.method} ${res.config.url} (${res.status} ${res.statusText}): ${JSON.stringify(res.data)}`);
            }
            return res;
        });
    }
    getAsset(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('get', `/api/asset/${id}`);
        });
    }
    getTask(id) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('get', `/api/task/${id}`);
        });
    }
    requestUploadUrl(assetName) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('post', `/api/asset/request-upload`, {
                name: assetName
            });
        });
    }
    uploadFile(url, content, mimeType, reportProgress) {
        const defaultMimeType = typeof File !== 'undefined' && content instanceof File
            ? content.type
            : 'application/octet-stream';
        return this.makeRequest('put', url, content, {
            headers: {
                contentType: mimeType || defaultMimeType
            },
            onUploadProgress: reportProgress && (p => reportProgress(p.loaded / p.total))
        });
    }
    transcodeAsset(src, profile, name) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('post', `/api/asset/transcode`, {
                assetId: src.id,
                name: name !== null && name !== void 0 ? name : `${src.name} (${profile.name})`,
                profile
            });
        });
    }
    exportAsset(id, params) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.makeRequest('post', `/api/asset/${id}/export`, params);
        });
    }
    // next level utilities
    waitTask(task, reportProgress) {
        var _a, _b, _c, _d;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let lastProgress = 0;
            while (((_a = task.status) === null || _a === void 0 ? void 0 : _a.phase) !== 'completed' &&
                ((_b = task.status) === null || _b === void 0 ? void 0 : _b.phase) !== 'failed') {
                const progress = (_c = task.status) === null || _c === void 0 ? void 0 : _c.progress;
                if (progress && progress !== lastProgress) {
                    if (reportProgress)
                        reportProgress(progress);
                    lastProgress = progress;
                }
                new Promise(resolve => setTimeout(resolve, 1000));
                task = yield this.getTask((_d = task.id) !== null && _d !== void 0 ? _d : '');
            }
            if (task.status.phase === 'failed') {
                throw new Error(`${task.type} task failed. error: ${task.status.errorMessage}`);
            }
            return task;
        });
    }
    makeRequest(method, url, data, additionalConfig) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.client.request(Object.assign(Object.assign({}, additionalConfig), { method,
                    url,
                    data }));
                return res.data;
            }
            catch (err) {
                if (!axios__default["default"].isAxiosError(err) || !err.response) {
                    throw err;
                }
                const { status, statusText, data } = err.response;
                let msg = JSON.stringify(data);
                if (Array.isArray(data.errors) && data.errors.length > 0) {
                    msg = data.errors[0];
                }
                throw new Error(`Request to ${url} failed (${status} ${statusText}): ${msg}`);
            }
        });
    }
}

function parseRawArgs(argv) {
    var _a;
    return yargs__default["default"]
        .command('$0 [filename]', '1-command mint a video NFT')
        .positional('filename', {
        describe: 'file to upload as an NFT',
        type: 'string'
    })
        .options({
        'api-key': {
            describe: 'API key to use for Livepeer API',
            type: 'string'
        },
        'asset-name': {
            describe: 'name for the asset created in Livepeer.com API',
            type: 'string'
        },
        'nft-metadata': {
            describe: 'additional JSON metadata to override default generated by Livepeer for the NFT',
            type: 'string',
            default: '{}'
        },
        'api-endpoint': {
            describe: 'the endpoint to use for the Livepeer API',
            type: 'string',
            default: prodApiEndpoint
        }
    })
        .usage(`
	Video NFT

  Mint a video NFT in 1 command with Livepeer.

	Usage: video-nft [filename] [options]`)
        .env('LP_')
        .help()
        .parse((_a = argv) !== null && _a !== void 0 ? _a : helpers.hideBin(process.argv));
}
const uuidRegex = /^[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}$/;
function promptMissing(args) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        let { apiKey, filename, assetName, nftMetadata } = args;
        if (!apiKey) {
            apiKey = yield inquirer__default["default"]
                .prompt({
                type: 'password',
                name: 'apiKey',
                message: 'Enter your Livepeer API key (learn more at http://bit.ly/lp-api-key):',
                mask: '*',
                validate: apiKey => uuidRegex.test(apiKey) || 'Not a valid API key'
            })
                .then(ans => ans.apiKey);
            console.log('Tip: You can set the LP_API_KEY environment variable to avoid this prompt.');
        }
        if (!filename) {
            filename = yield inquirer__default["default"]
                .prompt({
                type: 'input',
                name: 'filename',
                message: 'What file do you want to use?',
                validate: (value) => fs__namespace.existsSync(value) || 'File does not exist'
            })
                .then(ans => ans.filename);
            console.log('You can also send the filename as an argument to this command.');
        }
        if (!assetName) {
            assetName = yield inquirer__default["default"]
                .prompt({
                type: 'input',
                name: 'assetName',
                message: `What name do you want to give to your NFT?`,
                default: path__namespace.basename(filename)
            })
                .then(ans => ans.assetName);
        }
        if (nftMetadata === '{}') {
            const { shouldEdit } = yield inquirer__default["default"].prompt({
                type: 'confirm',
                name: 'shouldEdit',
                message: `Would you like to customize the NFT metadata?`,
                default: false
            });
            if (shouldEdit) {
                console.log(' - The `animation_url` and `properties.video` fields will be populated with the exported video URL.');
                console.log(' - Set any field to `null` to delete it.');
                nftMetadata = yield inquirer__default["default"]
                    .prompt({
                    type: 'editor',
                    name: 'nftMetadata',
                    message: 'Open text editor:',
                    default: JSON.stringify({
                        name: assetName,
                        description: `Livepeer video from asset ${JSON.stringify(assetName)}`,
                        image: `ipfs://bafkreidmlgpjoxgvefhid2xjyqjnpmjjmq47yyrcm6ifvoovclty7sm4wm`,
                        properties: {}
                    }, null, 2),
                    validate: (value) => {
                        try {
                            JSON.parse(value);
                            return true;
                        }
                        catch (e) {
                            return `Invalid JSON: ${e}`;
                        }
                    }
                })
                    .then(ans => ans.nftMetadata);
            }
        }
        return Object.assign(Object.assign({}, args), { apiKey,
            filename,
            assetName,
            nftMetadata });
    });
}
function parseCli(argv) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const args = yield parseRawArgs(argv);
        if (args.filename && !fs__namespace.existsSync(args.filename)) {
            throw new Error(`File ${args.filename} does not exist`);
        }
        if (fs__namespace.existsSync(args.nftMetadata)) {
            args.nftMetadata = fs__namespace.readFileSync(args.nftMetadata, 'utf8');
        }
        try {
            if (args.nftMetadata != '{}') {
                const metadata = JSON.parse(args.nftMetadata);
                console.log(`Using metadata:\n${JSON.stringify(metadata, null, 2)}`);
            }
        }
        catch (e) {
            throw new Error(`Invalid JSON in nft-metadata: ${e}`);
        }
        return promptMissing(args);
    });
}

var T=Object.defineProperty;var f=(e,t)=>()=>(e&&(t=e(e=0)),t);var d=(e,t)=>{for(var i in t)T(e,i,{get:t[i],enumerable:!0});};var y={};d(y,{default:()=>E});var E,p=f(()=>{E=async(e=[{}])=>(Array.isArray(e)||(e=[e]),new Promise((t,i)=>{let r=document.createElement("input");r.type="file";let l=[...e.map(s=>s.mimeTypes||[]),...e.map(s=>s.extensions||[])].join();r.multiple=e[0].multiple||!1,r.accept=l||"";let n=()=>c(i),a=s=>{typeof c=="function"&&c(),t(s);},c=e[0].legacySetup&&e[0].legacySetup(a,n,r);r.addEventListener("change",()=>{a(r.multiple?Array.from(r.files):r.files[0]);}),r.click();}));});var w={};d(w,{default:()=>I});var N,I,h=f(()=>{N=async e=>{let t=await e.getFile();return t.handle=e,t},I=async(e=[{}])=>{Array.isArray(e)||(e=[e]);let t=[];e.forEach((l,n)=>{t[n]={description:l.description||"",accept:{}},l.mimeTypes?l.mimeTypes.map(a=>{t[n].accept[a]=l.extensions||[];}):t[n].accept["*/*"]=l.extensions||[];});let i=await window.showOpenFilePicker({id:e[0].id,startIn:e[0].startIn,types:t,multiple:e[0].multiple||!1,excludeAcceptAllOption:e[0].excludeAcceptAllOption||!1}),r=await Promise.all(i.map(N));return e[0].multiple?r:r[0]};});var o={};d(o,{default:()=>M});var M,A=f(()=>{M=async(e=[{}])=>(Array.isArray(e)||(e=[e]),e[0].recursive=e[0].recursive||!1,new Promise((t,i)=>{let r=document.createElement("input");r.type="file",r.webkitdirectory=!0;let l=()=>a(i),n=c=>{typeof a=="function"&&a(),t(c);},a=e[0].legacySetup&&e[0].legacySetup(n,l,r);r.addEventListener("change",()=>{let c=Array.from(r.files);e[0].recursive?e[0].recursive&&e[0].skipDirectory&&(c=c.filter(s=>s.webkitRelativePath.split("/").every(S=>!e[0].skipDirectory({name:S,kind:"directory"})))):c=c.filter(s=>s.webkitRelativePath.split("/").length===2),n(c);}),r.click();}));});var x={};d(x,{default:()=>B});var v,B,g=f(()=>{v=async(e,t,i=e.name,r)=>{let l=[],n=[];for await(let a of e.values()){let c=`${i}/${a.name}`;a.kind==="file"?n.push(a.getFile().then(s=>(s.directoryHandle=e,s.handle=a,Object.defineProperty(s,"webkitRelativePath",{configurable:!0,enumerable:!0,get:()=>c})))):a.kind==="directory"&&t&&(!r||!r(a))&&l.push(v(a,t,c,r));}return [...(await Promise.all(l)).flat(),...await Promise.all(n)]},B=async(e={})=>{e.recursive=e.recursive||!1;let t=await window.showDirectoryPicker({id:e.id,startIn:e.startIn});return v(t,e.recursive,void 0,e.skipDirectory)};});var k={};d(k,{default:()=>W});async function $(e,t){let i=e.getReader(),r=new ReadableStream({start(n){return a();async function a(){return i.read().then(({done:c,value:s})=>{if(c){n.close();return}return n.enqueue(s),a()})}}}),l=new Response(r);return i.releaseLock(),new Blob([await l.blob()],{type:t})}var W,P=f(()=>{W=async(e,t={})=>{Array.isArray(t)&&(t=t[0]);let i=document.createElement("a"),r=e;"body"in e&&(r=await $(e.body,e.headers.get("content-type"))),i.download=t.fileName||"Untitled",i.href=URL.createObjectURL(r);let l=()=>a(reject),n=()=>{typeof a=="function"&&a();},a=t.legacySetup&&t.legacySetup(n,l,i);return i.addEventListener("click",()=>{setTimeout(()=>URL.revokeObjectURL(i.href),30*1e3),n();}),i.click(),null};});var j={};d(j,{default:()=>q});var q,L=f(()=>{q=async(e,t=[{}],i=null,r=!1)=>{Array.isArray(t)||(t=[t]),t[0].fileName=t[0].fileName||"Untitled";let l=[];if(t.forEach((c,s)=>{l[s]={description:c.description||"",accept:{}},c.mimeTypes?(s===0&&(e.type?c.mimeTypes.push(e.type):e.headers&&e.headers.get("content-type")&&c.mimeTypes.push(e.headers.get("content-type"))),c.mimeTypes.map(m=>{l[s].accept[m]=c.extensions||[];})):e.type&&(l[s].accept[e.type]=c.extensions||[]);}),i)try{await i.getFile();}catch(c){if(i=null,r)throw c}let n=i||await window.showSaveFilePicker({suggestedName:t[0].fileName,id:t[0].id,startIn:t[0].startIn,types:l,excludeAcceptAllOption:t[0].excludeAcceptAllOption||!1}),a=await n.createWritable();return "stream"in e?(await e.stream().pipeTo(a),n):"body"in e?(await e.body.pipeTo(a),n):(await a.write(blob),await a.close(),n)};});var F=(()=>{if(typeof self>"u")return !1;if("top"in self&&self!==top)try{top.location+"";}catch{return !1}else if("showOpenFilePicker"in self)return "showOpenFilePicker";return !1})(),u=F;var U=u?Promise.resolve().then(()=>(h(),w)):Promise.resolve().then(()=>(p(),y));async function _(...e){return (await U).default(...e)}u?Promise.resolve().then(()=>(g(),x)):Promise.resolve().then(()=>(A(),o));u?Promise.resolve().then(()=>(L(),j)):Promise.resolve().then(()=>(P(),k));// @license © 2020 Google LLC. Licensed under the Apache License, Version 2.0.

const openSeaNftSizeLimit = 100000000; // 100 MB
const min720pBitrate = 500000; // 0.5 Mbps
const minBitrate = 100000; // 0.1 Mbps
function getDesiredBitrate(asset, sizeLimit = openSeaNftSizeLimit) {
    var _a, _b, _c, _d, _e, _f;
    const size = (_a = asset.size) !== null && _a !== void 0 ? _a : 0;
    const bitrate = (_c = (_b = getVideoTrack(asset)) === null || _b === void 0 ? void 0 : _b.bitrate) !== null && _c !== void 0 ? _c : 0;
    if (size <= sizeLimit || !bitrate) {
        return null;
    }
    const audioTrack = (_e = (_d = asset.videoSpec) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e === void 0 ? void 0 : _e.find(t => t.type === 'audio');
    const audioBitrate = (_f = audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.bitrate) !== null && _f !== void 0 ? _f : 0;
    const desiredBitrate = Math.floor((bitrate + audioBitrate) * (sizeLimit / size) - audioBitrate);
    if (desiredBitrate < minBitrate) {
        throw new Error('Asset is too large to be downscaled to desired size');
    }
    return desiredBitrate;
}
function makeProfile(asset, desiredBitrate) {
    var _a;
    const { bitrate = 1, width = 0, height = 0 } = (_a = getVideoTrack(asset)) !== null && _a !== void 0 ? _a : {};
    // We only change the resolution if the bitrate changes too much. We don't go
    // below 720p though since the bitrate is the thing that really matters. We
    // don't need to handle aspect ratio since go-livepeer will do it for us.
    const referenceHeight = height * Math.sqrt(desiredBitrate / bitrate);
    const resolution = height < 480 || referenceHeight > 720
        ? { name: 'low-bitrate', width, height }
        : desiredBitrate < min720pBitrate
            ? { name: '480p', width: 854, height: 480 }
            : { name: '720p', width: 1280, height: 720 };
    return Object.assign(Object.assign({}, resolution), { bitrate: desiredBitrate, fps: 0 });
}
function getVideoTrack(asset) {
    var _a, _b;
    return (_b = (_a = asset.videoSpec) === null || _a === void 0 ? void 0 : _a.tracks) === null || _b === void 0 ? void 0 : _b.find(t => t.type === 'video');
}

const builtinChains = {
    '0x89': {
        spec: {
            chainId: '0x89',
            chainName: 'Polygon Mainnet',
            rpcUrls: ['https://polygon-rpc.com/'],
            nativeCurrency: { symbol: 'MATIC', decimals: 18 },
            blockExplorerUrls: ['https://polygonscan.com'],
            iconUrls: [
                'https://cloudflare-ipfs.com/ipfs/bafkreiduv5pzw233clfjuahv5lkq2xvjomapou7yarik2lynu3bjm2xki4'
            ]
        },
        defaultContract: '0x69C53E7b8c41bF436EF5a2D81DB759Dc8bD83b5F',
        opensea: {
            baseUrl: 'https://opensea.io',
            chainName: 'matic'
        }
    },
    '0x13881': {
        spec: {
            chainId: '0x13881',
            chainName: 'Polygon Testnet',
            rpcUrls: ['https://matic-mumbai.chainstacklabs.com'],
            nativeCurrency: { symbol: 'MATIC', decimals: 18 },
            blockExplorerUrls: ['https://mumbai.polygonscan.com']
        },
        defaultContract: '0xA4E1d8FE768d471B048F9d73ff90ED8fcCC03643',
        opensea: {
            baseUrl: 'https://testnets.opensea.io',
            chainName: 'mumbai'
        }
    }
};
function toHexChainId(chainId) {
    return chainId == null ? '' : ethers.utils.hexValue(chainId);
}
function getBuiltinChain(chainId) {
    return builtinChains[toHexChainId(chainId)] || null;
}

const asJsonRpcProvider = (ethOrPrv) => !ethOrPrv
    ? undefined
    : ethOrPrv instanceof ethers.ethers.providers.JsonRpcProvider
        ? ethOrPrv
        : new ethers.ethers.providers.Web3Provider(ethOrPrv);
const videoNftAbi = [
    'event Mint(address indexed sender, address indexed owner, string tokenURI, uint256 tokenId)',
    'function mint(address owner, string tokenURI) returns (uint256)'
];
class VideoNFT {
    constructor(api, web3) {
        this.api = new VodApi(api === null || api === void 0 ? void 0 : api.auth, api === null || api === void 0 ? void 0 : api.endpoint);
        this.ethProvider = asJsonRpcProvider(web3 === null || web3 === void 0 ? void 0 : web3.ethereum);
        // The chainId would not be really necessary since we can get it from the
        // provider. But the provider explodes if the chain changes, so we force
        // users to send the chainId here so it's clear they need to recreate
        // the SDK instance if the chain changes.
        this.chainId = toHexChainId(web3 === null || web3 === void 0 ? void 0 : web3.chainId);
    }
    createNft(args) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const file = yield this.pickFile();
            let asset = yield this.createAsset(args.assetName, file);
            if (!args.skipNormalize) {
                asset = yield this.nftNormalize(asset);
            }
            const ipfsInfo = yield this.exportToIPFS(asset.id, args.nftMetadata);
            if (!args.mint || !this.ethProvider) {
                return null;
            }
            const { mint: { contractAddress, to } } = args;
            const tx = yield this.mintNft((_a = ipfsInfo === null || ipfsInfo === void 0 ? void 0 : ipfsInfo.nftMetadataUrl) !== null && _a !== void 0 ? _a : '', contractAddress, to);
            return this.getMintedNftInfo(tx);
        });
    }
    pickFile() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof window === 'undefined') {
                throw new Error('pickFile is only supported in the browser');
            }
            const { handle } = yield _({
                description: 'MP4 Video files',
                mimeTypes: ['video/mp4'],
                extensions: ['.mp4', '.mov', '.m4v']
            });
            const file = yield (handle === null || handle === void 0 ? void 0 : handle.getFile());
            if (!file) {
                throw new Error('Failed to open file');
            }
            return file;
        });
    }
    createAsset(name, content, reportProgress = () => { }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { url: uploadUrl, asset: { id: assetId }, task } = yield this.api.requestUploadUrl(name);
            yield this.api.uploadFile(uploadUrl, content, undefined, p => reportProgress(p / 2));
            yield this.api.waitTask(task, p => reportProgress(0.5 + p / 2));
            return yield this.api.getAsset(assetId);
        });
    }
    checkNftNormalize(asset) {
        let desiredProfile = null;
        try {
            const desiredBitrate = getDesiredBitrate(asset);
            if (desiredBitrate) {
                desiredProfile = makeProfile(asset, desiredBitrate);
            }
            return {
                possible: true,
                desiredProfile
            };
        }
        catch (e) {
            return { possible: false, desiredProfile };
        }
    }
    nftNormalize(asset, reportProgress) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { possible, desiredProfile } = this.checkNftNormalize(asset);
            if (!possible || !desiredProfile) {
                return asset;
            }
            const transcode = yield this.api.transcodeAsset(asset, desiredProfile);
            yield this.api.waitTask(transcode.task, reportProgress);
            return yield this.api.getAsset(transcode.asset.id);
        });
    }
    exportToIPFS(assetId, nftMetadata, reportProgress) {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof nftMetadata === 'string') {
                nftMetadata = JSON.parse(nftMetadata);
            }
            let { task } = yield this.api.exportAsset(assetId, {
                ipfs: { nftMetadata }
            });
            task = yield this.api.waitTask(task, reportProgress);
            return (_b = (_a = task.output) === null || _a === void 0 ? void 0 : _a.export) === null || _b === void 0 ? void 0 : _b.ipfs;
        });
    }
    mintNft(tokenUri, contractAddress, to) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            contractAddress || (contractAddress = (_a = getBuiltinChain(this.chainId)) === null || _a === void 0 ? void 0 : _a.defaultContract);
            if (!contractAddress) {
                throw new Error('No contract address provided nor builtin chain');
            }
            if (!this.ethProvider) {
                throw new Error('No Ethereum provider configured');
            }
            const net = yield this.ethProvider.getNetwork();
            const currChainId = toHexChainId(net.chainId);
            if (currChainId !== this.chainId) {
                throw new Error(`Inconsistent chain ID: created for ${this.chainId} but found ${currChainId}`);
            }
            const signer = this.ethProvider.getSigner();
            const videoNft = new ethers.ethers.Contract(contractAddress, videoNftAbi, signer);
            const owner = to !== null && to !== void 0 ? to : (yield signer.getAddress());
            return yield videoNft.mint(owner, tokenUri);
        });
    }
    getMintedNftInfo(tx) {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const receipt = yield tx.wait();
            const mintEv = (_b = (_a = receipt.events) === null || _a === void 0 ? void 0 : _a.find(ev => (ev === null || ev === void 0 ? void 0 : ev.event) === 'Mint')) === null || _b === void 0 ? void 0 : _b.args;
            const tokenId = mintEv && mintEv.length > 3
                ? mintEv[3].toNumber()
                : undefined;
            let info = { tokenId };
            const chainInfo = getBuiltinChain(this.chainId);
            if (chainInfo === null || chainInfo === void 0 ? void 0 : chainInfo.opensea) {
                const { opensea: { baseUrl, chainName } } = chainInfo;
                const { to: contractAddr } = receipt;
                info = Object.assign(Object.assign({}, info), { opensea: {
                        contractUrl: `${baseUrl}/assets?search%5Bquery%5D=${contractAddr}`,
                        tokenUrl: !tokenId
                            ? undefined
                            : `${baseUrl}/assets/${chainName}/${contractAddr}/${tokenId}`
                    } });
            }
            return info;
        });
    }
}

function videoNft() {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const args = yield parseCli();
        const { apiKey, apiEndpoint: endpoint } = args;
        const sdk = new VideoNFT({
            auth: { apiKey },
            endpoint
        });
        let file = null;
        let asset;
        try {
            file = fs__default["default"].createReadStream(args.filename);
            printStep('Uploading file...');
            asset = yield sdk.createAsset(args.assetName, file, printProgress);
        }
        finally {
            file === null || file === void 0 ? void 0 : file.close();
        }
        asset = yield maybeTranscode(sdk, asset);
        printStep('Starting export...');
        let ipfs = yield sdk.exportToIPFS(asset.id, args.nftMetadata, printProgress);
        console.log(`Export successful! Result: \n${JSON.stringify(ipfs, null, 2)}`);
        printStep(`Mint your NFT at:\n` +
            `https://livepeer.com/mint-nft?tokenUri=${ipfs === null || ipfs === void 0 ? void 0 : ipfs.nftMetadataUrl}`);
    });
}
function printProgress(progress) {
    console.log(` - progress: ${100 * progress}%`);
}
function maybeTranscode(sdk, asset) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const { possible, desiredProfile } = sdk.checkNftNormalize(asset);
        if (!possible || !desiredProfile) {
            if (!possible) {
                console.error(`Warning: Asset is larger than OpenSea file limit and can't be transcoded down since it's too large. ` +
                    `It will still be stored in IPFS and referenced in the NFT metadata, so a proper application is still able to play it back. ` +
                    `For more information check http://bit.ly/opensea-file-limit`);
            }
            return asset;
        }
        console.log(`File is too big for OpenSea 100MB limit (learn more at http://bit.ly/opensea-file-limit).`);
        const { action } = yield inquirer__default["default"].prompt({
            type: 'list',
            name: 'action',
            message: 'What do you want to do?',
            choices: [
                {
                    value: 'transcode',
                    name: 'Transcode it to a lower quality so OpenSea is able to preview'
                },
                {
                    value: 'ignore',
                    name: 'Mint it as is (should work in any other platform that uses the NFT file)'
                }
            ]
        });
        if (action === 'ignore') {
            return asset;
        }
        printStep(`Transcoding asset to ${desiredProfile.name} at ${Math.round(desiredProfile.bitrate / 1024)} kbps bitrate`);
        return yield sdk.nftNormalize(asset, printProgress);
    });
}
let currStep = 0;
const printStep = (msg) => console.log(`${++currStep}. ${msg}`);
videoNft().catch(err => {
    console.error(err);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map
